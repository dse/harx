#!/usr/bin/env perl
use warnings;
use strict;
use feature 'say';

#------------------------------------------------------------------------------
use File::Basename qw(basename dirname);
our $PROGNAME = basename($0);

#------------------------------------------------------------------------------
use open IO => qw(:locale);
use Encode::Locale;
use Encode qw(decode);
BEGIN {
    @ARGV = map { decode('locale', $_, Encode::FB_CROAK) } @ARGV;
}

#------------------------------------------------------------------------------
our $EXTENSIONS = {
    # File::MimeInfo returns a list of extensions given a mime type
    # but the first one isn't always a good "canonical" one.
    'text/html'                => { ext => 'html' },
    'text/css'                 => { ext => 'css'  },
    'application/javascript'   => { ext => 'js'   },
    'text/javascript'          => { ext => 'js'   },
    'application/x-javascript' => { ext => 'js'   },
    'text/plain'               => { ext => 'txt'  },
    'image/png'                => { ext => 'png'  },
    'application/json'         => { ext => 'json' },
    'image/jpeg'               => { ext => 'jpg'  },
    'image/gif'                => { ext => 'gif'  },
};

our @exclude;
our $verbose;
our @urlPattern;
our $jsonPP;
our $mirror;

use JSON::XS qw();
use Path::Tiny qw(path);
use File::Path qw(make_path remove_tree);
use Sort::Naturally qw(nsort);
use File::MimeInfo qw(extensions mimetype);
use MIME::Base64 qw(decode_base64);
use Getopt::Long;
use File::Glob qw(:bsd_glob);
use Regexp::Wildcards;
use URI;

# we have to make a function call like this at somewhere around this
# point in order for future extensions() calls to work.
extensions('text/html');

my $rw = Regexp::Wildcards->new(type => 'unix');

Getopt::Long::Configure('bundling', 'gnu_compat', 'no_ignore_case');
Getopt::Long::GetOptions(
    'u|url-pattern=s' => \@urlPattern,
    'j|jsonpp|json-pp' => \$jsonPP,
    'v|verbose+' => \$verbose,
    'x|exclude=s' => sub {
        my $ext = lc $_[1];
        $ext =~ s{^\*?\.}{}; # make '*.jpg', '.jpg', and 'jpg' equivalent.
        push(@exclude, $rw->convert($ext));
    },
    'h|help' => sub { usage(); exit(0); },
    'm|mirror' => \$mirror,
);

sub usage { print(<<"END"); }
usage: $PROGNAME [<option> ...] [<harfile> ...]
options:
    -u, --url-pattern=<pattern>
    -x, --exclude=<ext|mimetype>     Exclude file extensions or MIME types.
                                     Accepts wildcards.
    -j, --jsonpp, --json-pp          Reformat JSON responses.
    -v, --verbose                    Increase stderr output.
    -h, --help                       Show this message.
END

@urlPattern = map { qr{$_} } @urlPattern;

my $json = JSON::XS->new()->ascii(1)->pretty(1)->canonical(1);
my $harCounter = 0;
local $/ = undef;               # slurp entire files at once
while (<>) {
    my $filenameCounter = 0;    # for generating filenames
    my $fileCounter = 0;

    my $o = $json->decode($_);
    my $base;
    my $har;
    if ($ARGV eq '-') {
        $base = sprintf('%04d.har', ++$harCounter);
        $har = '(standard input)';
    } else {
        $base = $ARGV;      # usually something like 'www.xxx.com.har'
        $har = $ARGV;
    }
    $base =~ s{\.har$}{};

    my $dir           = $base . '.har.d';
    my $indexFilename = $base . '.har.d/00INDEX.txt';

    if (-d $dir) {
        # leave files not matching harx-####.xxx alone.
        my @cleanup = (bsd_glob("$dir/response-data/harx-*"),
                       bsd_glob("$dir/harx-*"),
                       bsd_glob("$dir/00INDEX.txt"),
                       bsd_glob("$dir/post-data/post-*"));
        if (scalar @cleanup) {
            warn(sprintf("cleaning up %d files in %s\n", scalar @cleanup, $dir)) if $verbose;
            unlink(@cleanup);
        }
    }
    my $log = $o->{log};
    my $entries = $log->{entries};
    my $fh;
    make_path(dirname($indexFilename));
    open($fh, '>', $indexFilename) or die("cannot write $indexFilename: $!\n");
    my $col1len = length(sprintf('%s/response-data/harx-%04d%s', $dir, 0, '.xxxxxxxx'));

    # determine which ones to skip
  entry1:
    foreach my $entry (@$entries) {
        my $request  = $entry->{request};
        my $url      = $request->{url};
        if (scalar @urlPattern) {
            my $matches = 0;
            foreach my $urlPattern (@urlPattern) {
                if ($url =~ $urlPattern) {
                    $matches = 1;
                    last;
                }
            }
            if (!$matches) {
                $entry->{skip} = 1;
                next entry1;
            }
        }
        my $response = $entry->{response};
        my $status   = $response->{status};
        #   internal redir.   failed req.      invalid resp. code
        #   vvvvvvvvvvvvvv    vvvvvvvvvvvvv    vvvvvvvvvvvvv
        if ($status == 307 || $status > 399 || $status < 100) {
            $entry->{skip} = 1;
            next entry1;
        }
        my $content  = $response->{content};
        if (!defined $content->{text} || $content->{text} eq '' || !defined $content->{size} || !$content->{size}) {
            $entry->{skip} = 1;
            next entry1;
        }
        my $mimeType = $content->{mimeType};
        my ($ext, $type, @ext) = extension($mimeType, $url);
        foreach my $rx (@exclude) {
            if ($type =~ $rx) {
                $entry->{skip} = 1;
                next entry1;
            }
            foreach my $ext (@ext) {
                if ($ext =~ $rx) {
                    $entry->{skip} = 1;
                    next entry1;
                }
            }
        }
        $entry->{ext} = $ext;
    }

    # determine initial filenames
    foreach my $entry (@$entries) {
        my $url = $entry->{request}->{url};
        my $ext = $entry->{ext};
        my $filename = sprintf('%s/response-data/harx-%04d%s', $dir, ++$filenameCounter, $ext // '');
        if ($mirror) {
            my $uri = URI->new($url);
            my $basename = $uri->path;
            $basename =~ s{^/+}{};
            $basename =~ s{/+$}{};
            if ($basename eq '' || $basename eq '/') {
                $basename = 'ROOT';
            }
            my $query = $uri->query;
            if (defined $query && $query ne '') {
                $basename .= '?' . $query;
            }
            $filename = sformat('%{dir}s/response-data/%{scheme}s/%{host_port}s/%{basename}s',
                                dir       => $dir,
                                scheme    => $uri->scheme,
                                host_port => $uri->host_port,
                                basename  => $basename);
        }
        $entry->{filename} = $filename;
        $entry->{dirname} = dirname($filename);
        print("$filename\n");
    }

    # find any filename/dirname clashes
    my %entriesByFilename;
    my %entriesByDirname;
    my %filename;
    my %dirname;
    foreach my $entry (@$entries) {
        $filename{$entry->{filename}} += 1;
        $dirname{$entry->{dirname}} += 1;
        push(@{$entriesByFilename{$entry->{filename}}}, $entry);
        push(@{$entriesByDirname{$entry->{dirname}}}, $entry);
    }

    foreach my $filename (keys %filename) {
        if ($dirname{$filename}) {
            warn("filename/dirname clash:\n");
            warn("    $filename\n");
        }
    }

    foreach my $entry (@$entries) {
        next if $entry->{skip};

        my $request  = $entry->{request};
        my $method   = $request->{method};
        my $url      = $request->{url};
        my $response = $entry->{response};
        my $status   = $response->{status};
        my $content  = $response->{content};
        my $mimeType = $content->{mimeType};
        my ($ext, $type) = extension($mimeType, $url);
        my $encoding = $content->{encoding};
        my $size     = $content->{size};
        my $text     = $content->{text};

        my $binary = 0;
        if (defined $encoding) {
            if ($encoding eq 'base64') {
                $binary = 1;
                $text = decode_base64($text);
            } else {
                warn "WARNING: unrecognized encoding '$encoding': $url\n";
            }
        }

        if ($jsonPP && ($type eq 'application/json' || $type eq 'application/x-amz-json-1.1' || $url =~ m{\.json$}i)) {
            $text = jsonReencode($text);
        }

        my $filename = $entry->{filename};
        my $dirname = $entry->{dirname};
        if (!-e $dirname) {
            make_path(dirname($filename));
        } elsif (-d $dirname) {
            # do nothing
        } else {
            die("$dirname: file exists\n");
        }
        if ($binary) {
            path($filename)->spew({ binmode => ':raw' }, $text);
        } else {
            path($filename)->spew($text);
        }
        ++$fileCounter;

        say $fh sprintf('%-*s %-5s %-32s %-7s %s', $col1len, $filename, $binary ? '(bin)' : '-', $mimeType, $method, $url);

        if ($method eq 'POST') {
            my $postData = $request->{postData};
            if (defined $postData) {
                my $mimeType = $postData->{mimeType};
                $mimeType =~ s{;.*$}{};

                my $text = $postData->{text};
                if ($jsonPP && ($mimeType eq 'application/json' || $mimeType eq 'application/x-amz-json-1.1')) {
                    $text = jsonReencode($text);
                }

                my ($ext, $type) = extension($mimeType);
                my $filename = sprintf('%s/post-data/post-%04d%s', $dir, $filenameCounter, $ext // '');
                make_path(dirname($filename));
                path($filename)->spew($text);
                ++$fileCounter;

                say $fh sprintf('%-*s %-5s %-32s %-7s', $col1len, $filename, '-', $mimeType, '(data)');
            }
        }
    }
    close($fh);
    print("[$har]\n");
    print("    directory = $dir\n");
    print("    index     = $indexFilename\n");
    print("    fileCount = $fileCounter\n");
}

sub indent {
    my ($s, $indentFirstLine, $indentOtherLines) = @_;
    $indentFirstLine //= ' ' x 4;
    $indentOtherLines //= $indentFirstLine;
    $s =~ s{\A}{$indentFirstLine};
    $s =~ s{(?<=.)^}{$indentOtherLines}gms;
    return $s;
}

sub extension {
    my ($mimeType, $url) = @_;

    my $type = $mimeType;
    $type = undef if $type eq '';
    $type = undef if $type eq 'application/octet-stream';

    my @ext;
    if (defined $type) {
        @ext = extensions($type);
        @ext = grep { defined $_ && $_ ne '' } @ext;
    }

    if (defined $url && !scalar @ext) {
        my $uri = URI->new($url);
        my $path = $uri->path;
        if ($path =~ m{\.([0-9A-Za-z]+)$}) {
            my $ext = $1;
            if (!defined $type) {
                $type = mimetype("/thisdirectorydoesnotexist/thisfiledoesnotexist.$ext");
            }
            push(@ext, $ext);
        }
    }

    my $ext = eval { (defined $type && exists $EXTENSIONS->{$type}) ? $EXTENSIONS->{$type}->{ext} : undef } // $ext[0] // '';
    $ext = ".$ext" if $ext ne '';

    return ($ext, $type, @ext);
}

sub jsonReencode {
    my ($text) = @_;
    my $o = eval { $json->decode($text); };
    my $error = $@;
    if (defined $o) {
        return $json->encode($o);
    }
    if (!defined $error) {
        return;
    }

    # specific to certain AWS page data requests
    if ($error =~ m{^garbage after JSON object, at character offset \d+ \(before "!CW-Client-Metrics!\\n\.\.\."\)}) {
        my (@text) = split(/!CW-Client-Metrics!/, $text);
        @text = map { jsonReencode($_) } @text;
        return join("\n!CW-Client-Metrics!\n", @text);
    }

    die($error);
}

# behavior is undefined if * flag is used.
sub sformat {
    my ($format, %args) = @_;
    my @sprintf_args;
    my $sprintf_format = $format;
    $sprintf_format =~ s{ % \{ ([^\}]*) \} }{
        push(@sprintf_args, $args{$1});
        '%';
    }gxe;
    if (wantarray) {
        return ($sprintf_format, @sprintf_args);
    }
    return sprintf($sprintf_format, @sprintf_args);
}
